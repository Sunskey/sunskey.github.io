<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sunskey.top","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="做时间的朋友">
<meta property="og:type" content="website">
<meta property="og:title" content="Sunskey">
<meta property="og:url" content="https://sunskey.top/page/2/index.html">
<meta property="og:site_name" content="Sunskey">
<meta property="og:description" content="做时间的朋友">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Sunskey">
<meta property="article:tag" content="java, hexo, blog, next">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://sunskey.top/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Sunskey - 日拱一卒，不期而至</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Sunskey" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sunskey</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">日拱一卒，不期而至</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sunskey.top/mysql-learning15.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Sunskey">
      <meta itemprop="description" content="做时间的朋友">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sunskey">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/mysql-learning15.html" class="post-title-link" itemprop="url">大数据对数据库的影响</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-23 17:02:44 / 修改时间：18:58:07" itemprop="dateCreated datePublished" datetime="2021-01-23T17:02:44+08:00">2021-01-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">评论次数：</span>
    
    <a title="valine" href="/mysql-learning15.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/mysql-learning15.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="大数据对数据库的影响"><a href="#大数据对数据库的影响" class="headerlink" title="大数据对数据库的影响"></a>大数据对数据库的影响</h3><h4 id="全表扫描对server层的影响"><a href="#全表扫描对server层的影响" class="headerlink" title="全表扫描对server层的影响"></a>全表扫描对server层的影响</h4><p>1.获取一行，写入net_buffer。大小由net_buffer_length决定，默认16K。</p>
<p>2.重复获取行，直到net_buffer写满，调用网络接口发出去。</p>
<p>3.如果发送出去，就清空net_buffer，继续写入net_buffer。</p>
<p>4.如果发送函数返回EAGAIN或WSAEWOULDBLOCK，就表示本地网络栈（socket send buffer写满了），进入等待。直到网络栈重新可写，在继续发送。</p>
<p>MySQL是“边读边发的”，如果客户端接受得慢，会导致MySQL服务端由于结果发不出去，这个事务的执时间边长。</p>
<p>因此，对于正常的线上业务来说，如果一个查询结果不会很多的话，建议使用mysql_store_result这个接口，直接把查询结果保存在本地内存。</p>
<p>一个查询语句的状态变化是这样的</p>
<ul>
<li>MySQL查询语句进入执行阶段后，首先把状态设置成“Sending data”</li>
<li>然后，发送执行结果的列相关的信息给客户端</li>
<li>再执行执语句的流程</li>
<li>执行完成后，把状态设置成空字符串。</li>
</ul>
<p>“Sending data”并不是指“正在发送数据”，而可能是处于执行器过程中的任意阶段。</p>
<p>当一个线程处于“等待客户端接受结果”的状态，才会显示“Sending to client“；如果显示成”Sending data“，意思是正在执行。</p>
<h4 id="全表扫描对InnoDB的影响"><a href="#全表扫描对InnoDB的影响" class="headerlink" title="全表扫描对InnoDB的影响"></a>全表扫描对InnoDB的影响</h4><p>内存的数据页是在Buffer Pool(BP)中管理，在WAL里Buffer Pool起到了加速更新的作用。而实际上，Buffer Pool还是一个更重要的作用，加速查询。</p>
<p>Buffer Pool对查询的加速效果，依赖一个重要的指标，即：内存命中率。</p>
<p>可以通过show engine innodb status，查看BP命中率，一个稳定服务的线上系统，要保证响应时间符合要求的话，内存命中率要99%.</p>
<p>InnoDB buffer Pool的大小是由参数innodb_buffer_pool_size确定的，一般建议设置成可用物理内存60%-80%。</p>
<p>在InnoDB改进的LRU算法中，按照5：3的比例把整个LRU链表分成了young区域和old区域。</p>
<ul>
<li>扫描过程中，需要新插入的数据页，都被放到了old区域；</li>
<li>一个数据页里面由多条记录，这个数据页会被多次访问到，但是由于是顺序扫描，这个数据在第一次被访问和最后一次被访问的时间间隔不会超过1秒，因此还是会被保留在old区域。</li>
<li>在继续扫描后续数据，之前的这个数据页页不会在被访问到，于是始终没有机会移到链表头部，很快就会被淘汰。</li>
</ul>
<p>可以看见虽然也用到了Buffer Pool，但是对young区域完全没有影响，从而保证了Buffer Pool响应正常业务的查询。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sunskey.top/mysql-learning14.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Sunskey">
      <meta itemprop="description" content="做时间的朋友">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sunskey">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/mysql-learning14.html" class="post-title-link" itemprop="url">Kill不掉的语句</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-23 16:57:53 / 修改时间：17:02:33" itemprop="dateCreated datePublished" datetime="2021-01-23T16:57:53+08:00">2021-01-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">评论次数：</span>
    
    <a title="valine" href="/mysql-learning14.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/mysql-learning14.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Kill不掉的语句"><a href="#Kill不掉的语句" class="headerlink" title="Kill不掉的语句"></a>Kill不掉的语句</h3><p>两个kill命令：一个kill query + 线程id，表示终止这个线程中正在执行的语句。</p>
<p>一个是kill connection + 线程id，表示断开这个线程的连接。当然如果这个线程有语句正在执行，也要先停止正在执行的语句。</p>
<h4 id="kill执行的过程"><a href="#kill执行的过程" class="headerlink" title="kill执行的过程"></a>kill执行的过程</h4><p>1.一个语句执行过程中有多处“埋点”，在这些“埋点”的地方判断线程状态，如果发现线程状态是THD::KILL_QUERY，才开始进入语句终止逻辑。</p>
<p>2.如果处于等待状态，必须是一个可以被唤醒的等待，否则根本不会执行到“埋点”处</p>
<p>3.语句从开始进入终止逻辑，到终止逻辑完全完成，是由一个过程的。</p>
<h4 id="kill无效的两类情况"><a href="#kill无效的两类情况" class="headerlink" title="kill无效的两类情况"></a>kill无效的两类情况</h4><p>1.线程没有执行到判断线程状态的逻辑。</p>
<p>2.终止逻辑耗时较长。</p>
<ul>
<li>超大事务执行期间被Kill。回滚需要对事务执行期间生成的所有新数据版本做回收操作，耗时很长。</li>
<li>大查询回滚。产生了比较大的临时文件，删除临时文件可能需要等待IO资源，导致耗时边长。</li>
<li>DDL命令执行到最后的阶段，如果被Kill，需要删除中间过程的临时文件，也可能受IO资源影响。</li>
<li></li>
</ul>
<h4 id="关于kill客户端的误解"><a href="#关于kill客户端的误解" class="headerlink" title="关于kill客户端的误解"></a>关于kill客户端的误解</h4><p>1.Ctil + C 是MySQL客户端另外启动一个连接，然后发送一个kill query命令。</p>
<p>2.如果库里面的表特别多，连接就会很慢。</p>
<ul>
<li>执行show databases;</li>
<li>切到db1库，执行show tables;</li>
<li>把这两个命令的结果用于构建一个本地的哈希表</li>
</ul>
<p>真正耗时的步骤在第三步。我们感知的连接过程慢，其实并不是连接慢，也不是服务器慢，而是客户端慢。</p>
<p>如果在命令中加上-A，就可以关闭这个自动补全的功能，然后迅速返回。</p>
<p>3.-quick是一个更容易引起误会的参数，设置这个参数可能会降低服务端的性能。</p>
<p>客户端接受服务器返回结果方式两种</p>
<ul>
<li>本地缓存，也就是在本地开一片内存，结果存起来。如果用API开发，对应就是mysql_store_result。</li>
<li>不缓存，读一个处理一个。如果用API开发，对应就是mysql_use_result。</li>
</ul>
<p>MySQL客户端默认采用第一种方式，如果加上-quick，就会使用第二种不缓存的方式。</p>
<p>-quick可以达到以下的三种效果</p>
<ul>
<li>跳过表名的自动补全功能。</li>
<li>mysql_store_result需要申请本地内存来缓存结果，如果结果太大，可能会影响客户端本地机器性能。</li>
<li>不会把执行命令记录到本地的命令历史文件中。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sunskey.top/mysql-learning13.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Sunskey">
      <meta itemprop="description" content="做时间的朋友">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sunskey">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/mysql-learning13.html" class="post-title-link" itemprop="url">误删数据，如何恢复？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-23 16:52:37 / 修改时间：16:57:24" itemprop="dateCreated datePublished" datetime="2021-01-23T16:52:37+08:00">2021-01-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">评论次数：</span>
    
    <a title="valine" href="/mysql-learning13.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/mysql-learning13.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="误删数据，如何恢复？"><a href="#误删数据，如何恢复？" class="headerlink" title="误删数据，如何恢复？"></a>误删数据，如何恢复？</h3><p>误差数据的4个方法 </p>
<p>1.使用delete语句误删数据行</p>
<p>2.使用drop table或者truncate table语句误删数据表</p>
<p>3.使用drop database 语句误删除数据库</p>
<p>4.使用rm 命令误删除整个MySQL实例。</p>
<h4 id="误删行"><a href="#误删行" class="headerlink" title="误删行"></a>误删行</h4><p>利用Flashback工具通过闪回把数据恢复回来。需要确保binlog_format=row和binlog_row_image=FULL</p>
<ul>
<li>恢复数据</li>
</ul>
<p>具体恢复数据，对单个事务做如下处理</p>
<p>1.对于Insert语句，对应的binlog类型是write_rows_event，把它改写成delete_rows_event即可。</p>
<p>2.对于delete语句，将delete_rows_event改成为write_rows_event;</p>
<p>3.对于update，binlog里面记录了数据行修改前和修改后的值，对调这两行的位置即可。</p>
<p>对于多个事务，则需要将事务顺序调过来执行。</p>
<p>恢复数据比较安全的做法，是恢复出一个备份，找一个从库作为临时库，在这个临时库上执行这些操作，然后在将确认过的临时库的数据，恢复回主库。</p>
<ul>
<li>如何预防</li>
</ul>
<p>1.把sql_safe_updates参数设置为on，如果在update或者update写where条件或者没有包含索引，这条语句的执行就会报错。</p>
<p>2.代码上线前，必须经过SQL审计。</p>
<h4 id="误删库-表"><a href="#误删库-表" class="headerlink" title="误删库/表"></a>误删库/表</h4><p>这种情况下，想要恢复数据，就需要使用全量备份，加增量日志的方式了。这个方案要求线上有定期的全量备份，并且实时备份binlog，恢复流程如下。</p>
<p>1.取出最近一次全量备份</p>
<p>2.用备份恢复出一个临时库</p>
<p>3.从日志备份里面，去除凌晨0点之后的日志</p>
<p>4.把这些日志，除了误删除数据的语句外，全部应用到临时库。</p>
<p>加速过程</p>
<p>1.可以使用mysqlbinlog命令，加上一个-database参数，用来指定误删除的库。</p>
<p>2.应用日志，需要跳过12点误操作的那个语句的binlog。</p>
<p>如果没有使用GTID模式，先用–stop-position参数执行到误操作之前的日志，然后再用-start-position从误操作之后的日志继续执行。</p>
<p>如果使用了GTID模式，那么只需要执行set gtid_next= gtid1;bengin;commit;先把这个GTID加到临时实例的GTID集合，之后按照顺序执行binlog的时候，就会自动跳过误操作的语句。</p>
<p>效率问题：1.如果是表，只需要重放这张表 2.mysqlbinlog解析过程是单线程，效率低。</p>
<p>一种加速的方法是,在用备份恢复出临时实例之后，将这个临时实例设置成线上备库的从库。</p>
<p>1.在 start slave 之前，先通过执行﻿﻿change replication filter replicate_do_table = (tbl_name) 命令，就可以让临时库只同步误操作的表；</p>
<p>2.这样做也可以用上并行复制技术，来加速整个数据恢复过程。</p>
<p>思路：误删库或者表后，恢复数据的思路主要就是备份，在加上应用binlog的方式。</p>
<h5 id="延迟复制备库"><a href="#延迟复制备库" class="headerlink" title="延迟复制备库"></a>延迟复制备库</h5><p>如果有非常核心的业务，不允许太长的恢复时间，可以考虑搭建延迟复制的备库。MySQL 5.6版本引入。</p>
<p>延迟复制的备库是一种特殊的备库，通过CHANGE MASTER TO MASTER_DELAY = N 命令，可以指定这个备库持续保持跟主库有N秒的延迟。</p>
<h5 id="预防误删库-表的方法"><a href="#预防误删库-表的方法" class="headerlink" title="预防误删库/表的方法"></a>预防误删库/表的方法</h5><p>1.账号的分离。</p>
<ul>
<li>只给开DML权限，而不给truncate/drop权限。而如果业务开发人员有DDL需求的话，也可以开发管理系统。</li>
<li>如果是DBA团队成员，日常也都规定只使用只读账号，必要的时候才使用更新账号。</li>
</ul>
<p>2.制定操作规范。</p>
<ul>
<li><p>在删除表之前，必须先对表做改名的操作。确保无影响后，再删除这张表。</p>
</li>
<li><p>改表名的是偶，要求表明加固定的后缀，然后删除表你的动作必须通过管理系统执行。</p>
</li>
</ul>
<h4 id="rm-删除数据"><a href="#rm-删除数据" class="headerlink" title="rm 删除数据"></a>rm 删除数据</h4><p>只要不是恶意地把整个集群删除，而是只删除其中的某一个节点数据的话，HA系统就会开始工作，选出一个新的主库，从而保证整个集群的正常工作。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sunskey.top/mysql-learning12.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Sunskey">
      <meta itemprop="description" content="做时间的朋友">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sunskey">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/mysql-learning12.html" class="post-title-link" itemprop="url">如何判断一个数据库是不是出问题了？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-23 16:50:21 / 修改时间：16:52:24" itemprop="dateCreated datePublished" datetime="2021-01-23T16:50:21+08:00">2021-01-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">评论次数：</span>
    
    <a title="valine" href="/mysql-learning12.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/mysql-learning12.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="如何判断一个数据库是不是出问题了？"><a href="#如何判断一个数据库是不是出问题了？" class="headerlink" title="如何判断一个数据库是不是出问题了？"></a>如何判断一个数据库是不是出问题了？</h3><h4 id="select-1-判断"><a href="#select-1-判断" class="headerlink" title="select 1 判断"></a>select 1 判断</h4><p>实际上，select 1成功返回，只能说这个库的进程还在，并不能说明主库没问题。</p>
<p>例如：innodb_thread_concurrency参数控制InnoDB的并发线程上限。一旦并发线程达到这个值，InnoDB在接收新请求的时候，就会进入等待状态，直到有线程退出。</p>
<p>通过innodb_thread_concurrency设置为64-128之间的值。</p>
<p>并发连接：show processlist的结果里，看到的几千个连接。</p>
<p>并发查询：当前正在执行的语句。</p>
<p>实际上，在线程进入锁等待以后，并发线程的计数会减1，也就是等待行锁（间隙锁）的线程不算在128以内。</p>
<h4 id="查表判断"><a href="#查表判断" class="headerlink" title="查表判断"></a>查表判断</h4><p>为了能够检测InnoDB并发线程过多导致额系统不可用的系统。一般的做法是，在系统库里创建一个表，比如命令为health check，里面只放一行数据，然后定期执行。</p>
<p>但是磁盘满的时候，会影响正常写数据，而不影响读数据。</p>
<h4 id="更新判断"><a href="#更新判断" class="headerlink" title="更新判断"></a>更新判断</h4><p>常见的作法是放一个timestamp字段，用来表示最后一次执行检测的时间。</p>
<p>可以在mysql.health_check表上存入多行数据，并采用server_id做主键，这样可以保证主、备各自的检测命令不会发生冲突。</p>
<p>外部检测天然有一个问题，就是随机性。外部检测都需要定时轮询，所以系统可能已经出问题了 ，但是却需要等到下一个检测发起执行语句的时候。</p>
<h4 id="内部统计"><a href="#内部统计" class="headerlink" title="内部统计"></a>内部统计</h4><p>MySQL5.6版本以后提供perfomance_schema库，就在file_summary_by_event_name表里统计了每次IO请求的时间。</p>
<p>每一次操作数据库，performance都需要额外地统计这些信息，所以存在性能损耗。建议只开启自己需要的统计项进行统计，然后根据时间判断耗时情况，如果大于指定秒数（200ms）则认为系统不可用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sunskey.top/mysql-learning11.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Sunskey">
      <meta itemprop="description" content="做时间的朋友">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sunskey">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/mysql-learning11.html" class="post-title-link" itemprop="url">如何正确显示随机消息</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-23 10:09:03 / 修改时间：10:16:27" itemprop="dateCreated datePublished" datetime="2021-01-23T10:09:03+08:00">2021-01-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">评论次数：</span>
    
    <a title="valine" href="/mysql-learning11.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/mysql-learning11.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="如何正确显示随机消息"><a href="#如何正确显示随机消息" class="headerlink" title="如何正确显示随机消息"></a>如何正确显示随机消息</h3><h4 id="内存临时表"><a href="#内存临时表" class="headerlink" title="内存临时表"></a>内存临时表</h4><p>使用oder by rand()</p>
<p>对于InnoDB表，执行全字段排序会减少磁盘访问，因此会被优先选择。</p>
<p>对于内存表，回表过程只是简单地根据数据行的位置，直接访问内存得到数据，根本不会导致多访问磁盘，从而选择rowid排序。</p>
<p>select word from words order by rand() limit 3;</p>
<h5 id="整个执行过程"><a href="#整个执行过程" class="headerlink" title="整个执行过程"></a>整个执行过程</h5><p>1.创建一个临时表。这个临时表使用的是 memory 引擎，表里有两个字段，第一个字段是 double 类型，为了后面描述方便，记为字段 R，第二个字段是 varchar(64) 类型，记为字段 W。并且，这个表没有建索引。</p>
<p>2.从 words 表中，按主键顺序取出所有的 word 值。对于每一个 word 值，调用 rand() 函数生成一个大于 0 小于 1 的随机小数，并把这个随机小数和 word 分别存入临时表的 R 和 W 字段中，到此，扫描行数是 10000。</p>
<p>3.现在临时表有 10000 行数据了，接下来你要在这个没有索引的内存临时表上，按照字段 R 排序。</p>
<p>4.初始化 sort_buffer。sort_buffer 中有两个字段，一个是 double 类型，另一个是整型。</p>
<p>5.从内存临时表中一行一行地取出 R 值和位置信息（我后面会和你解释这里为什么是“位置信息”），分别存入 sort_buffer 中的两个字段里。</p>
<p>6.这个过程要对内存临时表做全表扫描，此时扫描行数增加 10000，变成了 20000。在 sort_buffer 中根据 R 的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫描行数。</p>
<p>7.排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出 word 值，返回给客户端。这个过程中，访问了表的三行数据，总扫描行数变成了 20003</p>
<img src="https://i.loli.net/2021/01/23/zer2NxcJFMV5afg.png" style="zoom:50%;" />

<p>如果你创建的表没有主键，或者把一个表的主键删掉了，那么 InnoDB 会自己生成一个长度为 6 字节的 rowid 来作为主键。</p>
<p>对于有主键的InnoDB表来说，整个rowid就是主键ID。</p>
<p>对于没有主键的InnoDB表来说，这个rowid就是系统生成的。</p>
<p>order by rand() 使用了内存临时表，内存临时表排序的时候使用了rowid排序算法。</p>
<h4 id="磁盘临时表"><a href="#磁盘临时表" class="headerlink" title="磁盘临时表"></a>磁盘临时表</h4><p>tmp_table_size限制了内存表的大小，默认值是16M。如果临时表的大小超过了tmp_table_size，那么内存临时表就会转成磁盘临时表。</p>
<p>磁盘临时表默认使用InnoDB，是由参数Internal_tmp_disk_storage_engine取控制。</p>
<p>MySQL5.6引入：优先队列排序算法，不需要使用临时文件的算法(归并排序），而是采用了优先队列排序算法。</p>
<img src="https://i.loli.net/2021/01/23/DFnrBLS4lY7cAWj.png" style="zoom:40%;" />

<p>总之，不管使用那种类型的临时表，order_by_rand()这种写法都会让计算过程非常复杂，需要大量的扫描行数。</p>
<h4 id="随机排序方法"><a href="#随机排序方法" class="headerlink" title="随机排序方法"></a>随机排序方法</h4><p>1.取得整个表的行数，并记为C.</p>
<p>2.取得Y = floor(C*rand())。</p>
<p>3.再利用你limit Y，1取得一行。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sunskey.top/mysql-learning10.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Sunskey">
      <meta itemprop="description" content="做时间的朋友">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sunskey">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/mysql-learning10.html" class="post-title-link" itemprop="url">MySQL 加锁规则</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-22 20:47:40" itemprop="dateCreated datePublished" datetime="2021-01-22T20:47:40+08:00">2021-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-23 10:17:47" itemprop="dateModified" datetime="2021-01-23T10:17:47+08:00">2021-01-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">评论次数：</span>
    
    <a title="valine" href="/mysql-learning10.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/mysql-learning10.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="加锁规则"><a href="#加锁规则" class="headerlink" title="加锁规则"></a>加锁规则</h3><p>加锁规则里面，包含了两个”原则‘、两个“优化”和一个“bug”。</p>
<p>1.原则1：加锁基本单位是next-key lock。前开后闭区间。</p>
<p>2.原则2：查找过程中访问到的对象才会加锁。</p>
<p>3.优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为 行锁。</p>
<p>4.优化2：索引上的等值查询，向右遍历且最后一个不满足等值条件的时候，next-key lock退化为间隙锁。</p>
<p>5.一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</p>
<img src="https://i.loli.net/2021/01/23/6ChDo3XBTL5jyEl.png" style="zoom:50%;" />



<h4 id="案例一：等值查询间隙锁"><a href="#案例一：等值查询间隙锁" class="headerlink" title="案例一：等值查询间隙锁"></a>案例一：等值查询间隙锁</h4><img src="https://i.loli.net/2021/01/23/otv9XOWDCjSdQcy.png" style="zoom:50%;" />

<h4 id="案例二：非唯一索引等值锁"><a href="#案例二：非唯一索引等值锁" class="headerlink" title="案例二：非唯一索引等值锁"></a>案例二：非唯一索引等值锁</h4><img src="https://i.loli.net/2021/01/23/pAhGQdrXiFV7alt.png" style="zoom:50%;" />

<ol>
<li><p>根据原则 1，加锁单位是 next-key lock，因此会给 (0,5]加上 next-key lock。</p>
</li>
<li><p>要注意 c 是普通索引，因此仅访问 c=5 这一条记录是不能马上停下来的，需要向右遍历，查到 c=10 才放弃。</p>
</li>
<li><p>根据原则 2，访问到的都要加锁，因此要给 (5,10]加 next-key lock。但是同时这个符合优化 2：等值判断，向右遍历，最后一个值不满足 c=5 这个等值条件，因此退化成间隙锁 (5,10)。</p>
</li>
<li><p>根据原则 2 ，只有访问到的对象才会加锁，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么 session B 的 update 语句可以执行完成。</p>
</li>
</ol>
<p>lock in share mode只锁覆盖索引，但是如果是for update 就不一样。执行for update，会顺便给主键索引上满足条件的行加上锁。</p>
<h4 id="案例三：主键索引范围锁"><a href="#案例三：主键索引范围锁" class="headerlink" title="案例三：主键索引范围锁"></a>案例三：主键索引范围锁</h4><p>mysql&gt; select * from t where id=10 for update;<br>mysql&gt; select * from t where id&gt;=10 and id&lt;11 for update;</p>
<p>语句1，只会对语句10进行加锁</p>
<img src="https://i.loli.net/2021/01/23/fX5AJePvWgon21M.png" style="zoom:50%;" />



<p>而语句2则是行锁id =10  和 next-key（10，15】</p>
<h4 id="案例四：非唯一索引范围锁"><a href="#案例四：非唯一索引范围锁" class="headerlink" title="案例四：非唯一索引范围锁"></a>案例四：非唯一索引范围锁</h4><img src="https://i.loli.net/2021/01/23/TfeIONuZJgvLEQb.png" style="zoom:50%;" />

<p>加锁范围为(5,10] 和 (10,15] 这两个 next-key lock。</p>
<h4 id="案例五：唯一索引范围锁bug"><a href="#案例五：唯一索引范围锁bug" class="headerlink" title="案例五：唯一索引范围锁bug"></a>案例五：唯一索引范围锁bug</h4><img src="https://i.loli.net/2021/01/23/owaiyQN7k6D8P1p.png" style="zoom:50%;" />

<p>yi因为id是唯一键，所以循环判断id = 15这一行就停止了 。但是实现上，InnoDB会往前扫面第一个不满足条件的行为止，因此（16，20】这个next - key -lock也会被锁上。</p>
<h4 id="案例六：非唯一索引上存在“等值”的例子"><a href="#案例六：非唯一索引上存在“等值”的例子" class="headerlink" title="案例六：非唯一索引上存在“等值”的例子"></a>案例六：非唯一索引上存在“等值”的例子</h4><img src="https://i.loli.net/2021/01/23/CtwdR236iqPOrcD.png" style="zoom:50%;" />

<p>这时，session A 在遍历的时候，先访问第一个 c=10 的记录。</p>
<p>同样地，根据原则 1，这里加的是 (c=5,id=5) 到 (c=10,id=10) 这个 next-key lock。</p>
<p>然后，session A 向右查找，直到碰到 (c=15,id=15) 这一行，循环才结束。</p>
<p>根据优化 2，这是一个等值查询，向右查找到了不满足条件的行，所以会退化成 (c=10,id=10) 到 (c=15,id=15) 的间隙锁。</p>
<p>也就是说，这个 delete 语句在索引 c 上的加锁范围，就是下图中蓝色区域覆盖的部分。</p>
<h4 id="案例七：limit语句加锁"><a href="#案例七：limit语句加锁" class="headerlink" title="案例七：limit语句加锁"></a>案例七：limit语句加锁</h4><img src="https://i.loli.net/2021/01/23/Jrz1ZMpx7qmuvPs.png" style="zoom:50%;" />

<p>这是因为，案例七里的 delete 语句明确加了 limit 2 的限制，因此在遍历到 (c=10, id=30) 这一行之后，满足条件的语句已经有两条，循环就结束了。因此，索引 c 上的加锁范围就变成了从（c=5,id=5) 到（c=10,id=30) 这个前开后闭区间，如下图所示：</p>
<img src="https://i.loli.net/2021/01/23/Yl6UQG3g74ENCKh.png" style="zoom:50%;" />

<p><strong>在删除数据的时候尽量加limit</strong>。这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围。</p>
<h4 id="案例八：一个死锁的例子"><a href="#案例八：一个死锁的例子" class="headerlink" title="案例八：一个死锁的例子"></a>案例八：一个死锁的例子</h4><img src="https://i.loli.net/2021/01/23/CAQ7tarNwmZKEMs.png" style="zoom:50%;" />

<p>session A 启动事务后执行查询语句加 lock in share mode，在索引 c 上加了 next-key lock(5,10] 和间隙锁 (10,15)；</p>
<p>session B 的 update 语句也要在索引 c 上加 next-key lock(5,10] ，进入锁等待；</p>
<p>然后 session A 要再插入 (8,8,8) 这一行，被 session B 的间隙锁锁住。由于出现了死锁，InnoDB 让 session B 回滚。</p>
<p>其实是这样的，session B 的“加 next-key lock(5,10] ”操作，实际上分成了两步，先是加 (5,10) 的间隙锁，加锁成功；然后加 c=10 的行锁，这时候才被锁住的。</p>
<p>实际上next-key lock 来分析。具体执行的时候，要分成间隙锁和行锁两端来执行的。</p>
<p>读已提交除在外键条件下不存在间隙锁，还有个优化，即：语句执行过程中加上的行锁，在语句执行完成后，就把“不满足条件的行”上的行锁直接释放了，不需要等到事务提交。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sunskey.top/mysql-learning09.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Sunskey">
      <meta itemprop="description" content="做时间的朋友">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sunskey">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/mysql-learning09.html" class="post-title-link" itemprop="url">什么是幻读</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-22 20:47:34" itemprop="dateCreated datePublished" datetime="2021-01-22T20:47:34+08:00">2021-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-23 10:08:55" itemprop="dateModified" datetime="2021-01-23T10:08:55+08:00">2021-01-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">评论次数：</span>
    
    <a title="valine" href="/mysql-learning09.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/mysql-learning09.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="什么是幻读"><a href="#什么是幻读" class="headerlink" title="什么是幻读"></a>什么是幻读</h3><img src="https://i.loli.net/2021/01/22/VCiQI2LT6zBneGM.png" style="zoom:50%;" />

<img src="https://i.loli.net/2021/01/22/hUTB4MzEsHq6mef.png" style="zoom:50%;" />

<p>1.在可重复读的级别下，普通的查询时快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读“下才会出现。</p>
<p>2.上面sessionB的修改结果，被session  A之后的select 语句用”当前读“看到，不能称为幻读。幻读仅专指”新插入的行“。</p>
<h4 id="幻读有什么问题"><a href="#幻读有什么问题" class="headerlink" title="幻读有什么问题"></a>幻读有什么问题</h4><p>1.破环了语义上的意思。”要把所有满足条件的行锁住，不准别的事务进行读写操作“</p>
<p>2.数据一致性的问题。</p>
<p>即使把所有的记录都加上锁，还是阻止不了新插入的记录。</p>
<h4 id="如何解决幻读"><a href="#如何解决幻读" class="headerlink" title="如何解决幻读"></a>如何解决幻读</h4><p>1.产生幻读的原因是，行锁只能锁住行，但是新插入这个动作，要更新记录之间的”间隙“。因此，为了解决幻读，InnoDB引入新的锁，也就是间隙锁（Gap Lock）。</p>
<img src="https://i.loli.net/2021/01/22/VhwrjMaP3b84fDo.png" style="zoom:50%;" />

<p>就这样不止给数据库中已有的6个记录加上行锁，还同时加了7个间隙锁。这样确保了无法插入新的记录。</p>
<p>跟间隙锁存在冲突关系的，是”往这个间隙中插入一个记录“这个操作。</p>
<p>间隙锁和行锁合成next-key lock，每个next-key lock是前开后闭区间。例如：分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum]。</p>
<p>间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的。</p>
<p>间隙锁是在可重复读隔离级别下才会生效的。如果把隔离级别设置成读提交，就没有间隙锁。但是需要解决数据和日志不一致的问题，需要把binlog格式设置为row。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sunskey.top/mysql-learning08.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Sunskey">
      <meta itemprop="description" content="做时间的朋友">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sunskey">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/mysql-learning08.html" class="post-title-link" itemprop="url">order by 工作原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-22 20:37:19 / 修改时间：20:55:36" itemprop="dateCreated datePublished" datetime="2021-01-22T20:37:19+08:00">2021-01-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">评论次数：</span>
    
    <a title="valine" href="/mysql-learning08.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/mysql-learning08.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="order-by工作原理"><a href="#order-by工作原理" class="headerlink" title="order by工作原理"></a>order by工作原理</h3><h4 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h4><p>MySQL会给每个线程分配一块内存用于排序，称为sort buffer。</p>
<p>1.初始化 sort_buffer，确定放入 name、city、age 这三个字段；</p>
<p>2.从索引 city 找到第一个满足 city=’杭州’条件的主键 id，也就是图中的 ID_X；</p>
<p>3.到主键 id 索引取出整行，取 name、city、age 三个字段的值，存入 sort_buffer 中；</p>
<p>4.从索引 city 取下一个记录的主键 id；</p>
<p>5.重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的 ID_Y；</p>
<p>6.对 sort_buffer 中的数据按照字段 name 做快速排序；</p>
<p>7.按照排序结果取前 1000 行返回给客户端。</p>
<p>sort_buffer_size ，就是MySQL为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于sort_buffer_size，排序就在内存中完成。如果数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。</p>
<img src="https://i.loli.net/2021/01/22/XrfTwBDKqWbPmFd.png" style="zoom:50%;" />

<h4 id="rowid排序"><a href="#rowid排序" class="headerlink" title="rowid排序"></a>rowid排序</h4><p>如果sort_buffer里面要存放的字段数太多，这样内存能存的行数很少，要分成很多个临时文件，排序性能会很差。可以通过修改max_length_for_sort_data的值来改变排序算法。</p>
<p>1.初始化 sort_buffer，确定放入两个字段，即 name 和 id；</p>
<p>2.从索引 city 找到第一个满足 city=’杭州’条件的主键 id，也就是图中的 ID_X；</p>
<p>3.到主键 id 索引取出整行，取 name、id 这两个字段，存入 sort_buffer 中；</p>
<p>4.从索引 city 取下一个记录的主键 id；</p>
<p>5.重复步骤 3、4 直到不满足 city=’杭州’条件为止，也就是图中的 ID_Y；</p>
<p>6.对 sort_buffer 中的数据按照字段 name 进行排序；</p>
<p>7.遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端。</p>
<img src="https://i.loli.net/2021/01/22/9LYQciKfheZ5lxE.png" style="zoom:50%;" />

<h4 id="全字段排序-VS-Rowid排序"><a href="#全字段排序-VS-Rowid排序" class="headerlink" title="全字段排序 VS Rowid排序"></a>全字段排序 VS Rowid排序</h4><p>由于Rowid排序涉及到回表，如果内存足够，就优先使用内存，即全字段排序。</p>
<p>优化手段：可以使用覆盖索引，索引上的信息足够满足查询请求，不需要再回主键索引上去取数据。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sunskey.top/mysql-learning07.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Sunskey">
      <meta itemprop="description" content="做时间的朋友">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sunskey">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/mysql-learning07.html" class="post-title-link" itemprop="url">MySQL 保证数据不丢失的秘密</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-22 20:18:12 / 修改时间：20:55:39" itemprop="dateCreated datePublished" datetime="2021-01-22T20:18:12+08:00">2021-01-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">评论次数：</span>
    
    <a title="valine" href="/mysql-learning07.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/mysql-learning07.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="保证数据不丢失的秘密"><a href="#保证数据不丢失的秘密" class="headerlink" title="保证数据不丢失的秘密"></a>保证数据不丢失的秘密</h3><h4 id="binlog写入机制"><a href="#binlog写入机制" class="headerlink" title="binlog写入机制"></a>binlog写入机制</h4><p>binlog写入逻辑：事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写到binlog中。</p>
<p>每个线程由自己的binlog cache ,但是共用同一份binlog文件。</p>
<p>write，指的是把日志写入文件系统的page cache,并没有把数据持久化到磁盘，所以速度快。</p>
<p>fsync，将数据持久化到磁盘的操作。</p>
<img src="https://i.loli.net/2021/01/22/unLfoqTdmyXH1pc.png" style="zoom:50%;" />

<p>write和fsync的时机，是由参数sync_binlog控制的；</p>
<p>1.sync_binlog = 0的时候，表示每次提交事务都只write，不fsync;</p>
<p>2.sync_binlog =1的时候，表示每次提交事务都会执行fsync;</p>
<p>3.sync_binlog=N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</p>
<h4 id="redo-log的写入机制"><a href="#redo-log的写入机制" class="headerlink" title="redo log的写入机制"></a>redo log的写入机制</h4><img src="https://static001.geekbang.org/resource/image/9d/d4/9d057f61d3962407f413deebc80526d4.png" alt="img" style="zoom:50%;" />

<p>1.存在redo log buffer中，物理上是在MySQL进程内存中。</p>
<p>2.写到磁盘（write）,但是没有持久化(fsync)，物理上文件系统的page cache里面。</p>
<p>3.持久化到磁盘，对应的是hard disk。</p>
<p>InnoDB提供了innodb_flush_log_at_trx_commit参数控制redo log的写入策略。</p>
<p>0：表示每次事务提交时都只是把redo log留在redo log buffer中</p>
<p>1：表示每次事务提交都将redo log持久化硬盘</p>
<p>2：每次提交都只是把redo log写到page cache</p>
<p>InnoDB有一个后台线程，每间隔一秒，就会把redo log buffer中的日志，调用write 写到文件系统的page cache ，然后fsync持久化磁盘。</p>
<p>3种情况会把让没有提交事务的redo log写入到磁盘中</p>
<p>1.后台线程每秒一次的轮询操作。</p>
<p>2.redo log buffer占用的空间即将达到innodb_log_buffer_size一半的时候，后台线程会主动写盘。</p>
<p>3.并行的事务提交的时候，顺带将这个事务的redo log buffer持久化到磁盘。</p>
<p>MySQL的双一配置。指的就是sync_binlog和innodb_flush_log_at_trx_commit都设置成1。一个事务完整提交前，需要等待两次刷盘，一次是redo log（prepare ）,一次是binlog.</p>
<p>日志逻辑序列（LSN）是单调递增的，用来对应redo log的一个个写入点。每次写入length的redo log，LSN的值就会加上length。</p>
<p>一次组提交里面，里面的组员越多，节约磁盘IOPS的效果越好。</p>
<p>日志记录过程</p>
<img src="https://i.loli.net/2021/01/22/B2GzKH3tRJqySns.png" style="zoom:50%;" />



<p>如果想binlog提升组提交的效果，可以通过设置binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 来实现。</p>
<p>1.binlog_group_commit_sync_delay参数，表示多少微秒后才调用fsync</p>
<p>2.binlog_group_commit_sync_no_delay_count，表示多少次以后才调用fsync</p>
<p>如果MySQL出现了性能瓶颈，而且瓶颈在IO上</p>
<p>1.通过设置binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count参数你，减少binlog的写盘速度。</p>
<p>2.将sync_binlog设置大于1，这样做的风险是，这个主机掉电会丢失binlog日志。</p>
<p>3.innodb_flush_log_at_trx_commit 设置为 2。这样做的风险是，主机掉电的时候会丢数据。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sunskey.top/mysql-learning06.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Sunskey">
      <meta itemprop="description" content="做时间的朋友">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sunskey">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/mysql-learning06.html" class="post-title-link" itemprop="url">MySQL 提高性能的办法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-22 20:18:09 / 修改时间：20:35:08" itemprop="dateCreated datePublished" datetime="2021-01-22T20:18:09+08:00">2021-01-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">评论次数：</span>
    
    <a title="valine" href="/mysql-learning06.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/mysql-learning06.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="MySQL-提高性能的办法"><a href="#MySQL-提高性能的办法" class="headerlink" title="MySQL 提高性能的办法"></a>MySQL 提高性能的办法</h3><p>短连接存在的一个风险，就是一旦数据库处理得慢一些，连接数就会暴涨。</p>
<p>max_connection参数，用来控制一个MySQL最大连接数，超过这个值，系统就会提示“too many connections”从而导致数据库不可用。</p>
<p>解决方案</p>
<p>1.先处理掉那些占着链接但是不工作的线程。</p>
<p>如果连接数过多，可以优先断开事务外空闲太久的链接；如果这样还不够，在考虑断开事务内空闲太久的链接。</p>
<p>使用 kill connection + id的方式，使用show processlist查看结果。</p>
<p>2.减少连接过程的消耗</p>
<p>跳过权限验证的方法是：重启数据库，并使用-skip-grant-tables参数启动。这样连接过程和语句执行过程都会跳过权限校验阶段。(但是不建议这么做，风险极高)。</p>
<h4 id="慢查询性能问题"><a href="#慢查询性能问题" class="headerlink" title="慢查询性能问题"></a>慢查询性能问题</h4><p>1.索引没有设计好</p>
<p>2.SQL语句没写好</p>
<p>3.MySQL选错了索引</p>
<p>1.上线前，在测试环境，把慢查询日志打开，并且把long_query_time设置成0，确保每个语句都会被记录</p>
<p>2.在测试表插入线上的数据，做一遍回归测试</p>
<p>3.观察慢查询里每类语句的输出，特别留意Row_examined字段是否一致。</p>
<p>call query_rewrite.flush_rewrite_rules() 这个存储过程，是让插入的新规则生效，也就是我们说的“查询重写”。</p>
<h4 id="QPS突增问题"><a href="#QPS突增问题" class="headerlink" title="QPS突增问题"></a>QPS突增问题</h4><p>1.如果是由全新业务的bug导致的，那么就可以从数据库直接把白名单去掉。</p>
<p>2.如果这个新功能使用的单独的数据库用户，可以直接删除用户。</p>
<p>3.如果跟主题功能绑定在一块，使用语句重写的功能，把压力最大的SQL直接重写成“select 1”返回。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sunskey"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">Sunskey</p>
  <div class="site-description" itemprop="description">做时间的朋友</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

   <div class="feed-link motion-element">
     <a href="/atom.xml" rel="alternate">
       <i class="fa fa-rss"></i>
       RSS
     </a>
   </div>

  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Sunskey" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Sunskey" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:154218965@qq.com" title="E-Mail → mailto:154218965@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sunskey</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'IeQnDEu3RFIAA4RTfDqdXeV2-gzGzoHsz',
      appKey     : 'eSw8Svi50Fp5BMlPaiSS02nv',
      placeholder: "快来发表自己的评论吧",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
    //新增以下代码即可，可以移除.info下所有子节点。
var infoEle = document.querySelector('#valine-comments .vpower');
infoEle.style.display='none'; 
 }, window.Valine);
});


</script>

</body>
</html>
